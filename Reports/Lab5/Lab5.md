# Topic: Parser & Building an Abstract Syntax Tree

### Course: Formal Languages & Finite Automata
### Author: Braguta Adelia, FAF-213

---

## Theory

In computer science, parsers are essential tools for analyzing and interpreting programming languages. They take raw 
source code and transform it into a structured representation. One important task of parsers is constructing an Abstract
Syntax Tree (AST), which captures the code's hierarchical structure and meaning.

A parser receives tokens generated by a lexer and builds a parse tree or AST. The lexer breaks down the code into tokens
like keywords, identifiers, and operators. The parser uses grammar rules to analyze the tokens and create a hierarchical
representation of the code.

The Abstract Syntax Tree represents the code's essential relationships and operations, abstracting the specific language
details. It organizes the syntax into a tree structure, with nodes representing language constructs like functions or
statements. The nodes are connected through parent-child relationships.

Building an AST involves parsing the tokens and creating nodes for each language construct. The parser follows grammar
rules and parsing techniques to construct an accurate AST. It also validates syntax and reports errors.

The AST serves as an intermediate representation for various purposes. It aids compilers, interpreters, and analyzers in
generating code, optimizing it, or analyzing its structure. Additionally, ASTs facilitate tasks like refactoring, code
generation, and documentation.

Parsers and Abstract Syntax Trees are fundamental to language processing tools. They enable efficient analysis, 
interpretation, and transformation of programs, supporting robust software development and language tooling.

---

## Objective:

1. Get familiar with parsing, what it is and how it can be programmed [1].
2. Get familiar with the concept of AST [2].
3. In addition to what has been done in the 3rd lab work do the following:
    1. In case you didn't have a type that denotes the possible types of tokens you need to:
        1. Have a type TokenType (like an enum) that can be used in the lexical analysis to categorize the tokens.
        2. Please use regular expressions to identify the type of the token.
    2. Implement the necessary data structures for an AST that could be used for the text you have processed in the 3rd lab work.
    3. Implement a simple parser program that could extract the syntactic information from the input text.

---

## Implementation description

The Parser class represents the parser component. It takes a list of tokens as input and maintains the current token index
for tracking the progress of parsing.

```
public int parseExpression() throws Exception {
    int result = parseTerm();

    while (currentToken().getType() == TokenType.PLUS || currentToken().getType() == TokenType.MINUS) {
        TokenType operator = currentToken().getType();
        consumeToken(); // Consume the operator token

        int term = parseTerm();
        if (operator == TokenType.PLUS) {
            result += term;
        } else if (operator == TokenType.MINUS) {
            result -= term;
        } else {
            throw new Exception("Unexpected operator: " + operator);
        }
    }

    return result;
}
```

The parseExpression method is responsible for parsing the top-level expression. It starts by calling parseTerm() to parse
the first term. Then, it enters a loop to handle any subsequent addition or subtraction operations. It checks the type of
the current token and determines the operator. The consumeToken() method is called to move to the next token. parseTerm()
is called again to parse the next term. The operator is then applied to the result variable based on its type (PLUS or MINUS).
If an unexpected operator is encountered, an exception is thrown. Finally, the resulting value is returned.

```
private int parseTerm() throws Exception {
    int result = parseFactor();

    while (currentToken().getType() == TokenType.MULTIPLY || currentToken().getType() == TokenType.DIVIDE) {
        TokenType operator = currentToken().getType();
        consumeToken(); // Consume the operator token

        int factor = parseFactor();
        if (operator == TokenType.MULTIPLY) {
            result *= factor;
        } else if (operator == TokenType.DIVIDE) {
            result /= factor;
        } else {
            throw new Exception("Unexpected operator: " + operator);
        }
    }

    return result;
}
```

The parseTerm method handles parsing terms, which are the building blocks of expressions. It starts by calling 
parseFactor() to parse the first factor. Then, it enters a loop to handle any subsequent multiplication or division
operations. Similar to parseExpression(), it checks the type of the current token to determine the operator. The
consumeToken() method is called to move to the next token. parseFactor() is called again to parse the next factor.
The operator is then applied to the result variable based on its type (MULTIPLY or DIVIDE). If an unexpected operator
is encountered, an exception is thrown. Finally, the resulting value is returned.

```
private int parseFactor() throws Exception {
    if (currentToken().getType() == TokenType.NUMBER) {
        int value = Integer.parseInt(currentToken().getValue());
        consumeToken(); // Consume the number token
        return value;
    } else {
        throw new Exception("Invalid factor: " + currentToken().getValue());
    }
}
```

The parseFactor method handles parsing factors, which in this case are numbers. It checks if the current token is of type 
NUMBER. If so, it extracts the integer value from the token's value using Integer.parseInt(). The consumeToken() method
is called to move to the next token. The extracted value is returned as the factor. If the current token is not a number,
an exception is thrown.

```
private Token currentToken() {
    return tokens.get(currentTokenIndex);
}

private void consumeToken() {
    currentTokenIndex++;
}
```

The currentToken method returns the token at the current index. It provides convenient access to the current token during parsing.

The consumeToken method increments the currentTokenIndex to move to the next token. It is called after successfully processing a token.

That covers the main components and methods of the Parser class.

---

## Result

```
Expression: 4 + 2 * 3 - 8 / 2
Expression passed
```

```
Expression: 4 + 2 $ 3 - 8 / 2
Error: Unexpected character: $
```

```
Expression:  
Error: Index 0 out of bounds for length 0
```

---

## Conclusion

In summary, studying the Parser class has provided valuable insights into parsing and evaluating arithmetic expressions.
The recursive parsing techniques and handling of operators and operands demonstrated the importance of proper precedence
and associativity. This knowledge of parsers and abstract syntax trees is fundamental for language processing, enabling 
analysis, interpretation, and code generation. Overall, this experience deepened our understanding of language mechanisms
and lays the groundwork for future growth in the field of language processing.

---

## References

[1] [Parsing Wiki](https://en.wikipedia.org/wiki/Parsing)

[2] [Abstract Syntax Tree Wiki](https://en.wikipedia.org/wiki/Abstract_syntax_tree)

[Abstract Syntax Tree vs Parse Tree](https://www.geeksforgeeks.org/abstract-syntax-tree-vs-parse-tree/)